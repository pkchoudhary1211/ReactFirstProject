{"ast":null,"code":"'use strict';\n\nvar libmime = require('libmime');\n\nvar libqp = require('libqp');\n\nvar libbase64 = require('libbase64');\n\nvar punycode = require('punycode');\n\nvar addressparser = require('addressparser');\n\nvar stream = require('stream');\n\nvar PassThrough = stream.PassThrough;\n\nvar fs = require('fs');\n\nvar fetch = require('nodemailer-fetch');\n\nvar crypto = require('crypto');\n\nvar os = require('os');\n\nmodule.exports = MimeNode;\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\n\nfunction MimeNode(contentType, options) {\n  this.nodeCounter = 0;\n  options = options || {};\n  /**\n   * shared part of the unique multipart boundary\n   */\n\n  this.baseBoundary = options.baseBoundary || Date.now().toString() + Math.random();\n  this.boundaryPrefix = options.boundaryPrefix || '----sinikael';\n  this.disableFileAccess = !!options.disableFileAccess;\n  this.disableUrlAccess = !!options.disableUrlAccess;\n  /**\n   * If date headers is missing and current node is the root, this value is used instead\n   */\n\n  this.date = new Date();\n  /**\n   * Root node for current mime tree\n   */\n\n  this.rootNode = options.rootNode || this;\n  /**\n   * If true include Bcc in generated headers (if available)\n   */\n\n  this.keepBcc = !!options.keepBcc;\n  /**\n   * If filename is specified but contentType is not (probably an attachment)\n   * detect the content type from filename extension\n   */\n\n  if (options.filename) {\n    /**\n     * Filename for this node. Useful with attachments\n     */\n    this.filename = options.filename;\n\n    if (!contentType) {\n      contentType = libmime.detectMimeType(this.filename.split('.').pop());\n    }\n  }\n  /**\n   * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n   */\n\n\n  this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n  /**\n   * Immediate parent for this node (or undefined if not set)\n   */\n\n  this.parentNode = options.parentNode;\n  /**\n   * Hostname for default message-id values\n   */\n\n  this.hostname = options.hostname;\n  /**\n   * An array for possible child nodes\n   */\n\n  this.childNodes = [];\n  /**\n   * Used for generating unique boundaries (prepended to the shared base)\n   */\n\n  this._nodeId = ++this.rootNode.nodeCounter;\n  /**\n   * A list of header values for this node in the form of [{key:'', value:''}]\n   */\n\n  this._headers = [];\n  /**\n   * True if the content only uses ASCII printable characters\n   * @type {Boolean}\n   */\n\n  this._isPlainText = false;\n  /**\n   * True if the content is plain text but has longer lines than allowed\n   * @type {Boolean}\n   */\n\n  this._hasLongLines = false;\n  /**\n   * If set, use instead this value for envelopes instead of generating one\n   * @type {Boolean}\n   */\n\n  this._envelope = false;\n  /**\n   * If set then use this value as the stream content instead of building it\n   * @type {String|Buffer|Stream}\n   */\n\n  this._raw = false;\n  /**\n   * Additional transform streams that the message will be piped before\n   * exposing by createReadStream\n   * @type {Array}\n   */\n\n  this._transforms = [];\n  /**\n   * If content type is set (or derived from the filename) add it to headers\n   */\n\n  if (contentType) {\n    this.setHeader('Content-Type', contentType);\n  }\n} /////// PUBLIC METHODS\n\n/**\n * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n *\n * @param {String} [contentType] Optional content type\n * @param {Object} [options] Optional options object\n * @return {Object} Created node object\n */\n\n\nMimeNode.prototype.createChild = function (contentType, options) {\n  if (!options && typeof contentType === 'object') {\n    options = contentType;\n    contentType = undefined;\n  }\n\n  var node = new MimeNode(contentType, options);\n  this.appendChild(node);\n  return node;\n};\n/**\n * Appends an existing node to the mime tree. Removes the node from an existing\n * tree if needed\n *\n * @param {Object} childNode node to be appended\n * @return {Object} Appended node object\n */\n\n\nMimeNode.prototype.appendChild = function (childNode) {\n  if (childNode.rootNode !== this.rootNode) {\n    childNode.rootNode = this.rootNode;\n    childNode._nodeId = ++this.rootNode.nodeCounter;\n  }\n\n  childNode.parentNode = this;\n  this.childNodes.push(childNode);\n  return childNode;\n};\n/**\n * Replaces current node with another node\n *\n * @param {Object} node Replacement node\n * @return {Object} Replacement node\n */\n\n\nMimeNode.prototype.replace = function (node) {\n  if (node === this) {\n    return this;\n  }\n\n  this.parentNode.childNodes.forEach(function (childNode, i) {\n    if (childNode === this) {\n      node.rootNode = this.rootNode;\n      node.parentNode = this.parentNode;\n      node._nodeId = this._nodeId;\n      this.rootNode = this;\n      this.parentNode = undefined;\n      node.parentNode.childNodes[i] = node;\n    }\n  }.bind(this));\n  return node;\n};\n/**\n * Removes current node from the mime tree\n *\n * @return {Object} removed node\n */\n\n\nMimeNode.prototype.remove = function () {\n  if (!this.parentNode) {\n    return this;\n  }\n\n  for (var i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n    if (this.parentNode.childNodes[i] === this) {\n      this.parentNode.childNodes.splice(i, 1);\n      this.parentNode = undefined;\n      this.rootNode = this;\n      return this;\n    }\n  }\n};\n/**\n * Sets a header value. If the value for selected key exists, it is overwritten.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\n\n\nMimeNode.prototype.setHeader = function (key, value) {\n  var added = false,\n      headerValue; // Allow setting multiple headers at once\n\n  if (!value && key && typeof key === 'object') {\n    // allow {key:'content-type', value: 'text/plain'}\n    if (key.key && 'value' in key) {\n      this.setHeader(key.key, key.value);\n    } // allow [{key:'content-type', value: 'text/plain'}]\n    else if (Array.isArray(key)) {\n        key.forEach(function (i) {\n          this.setHeader(i.key, i.value);\n        }.bind(this));\n      } // allow {'content-type': 'text/plain'}\n      else {\n          Object.keys(key).forEach(function (i) {\n            this.setHeader(i, key[i]);\n          }.bind(this));\n        }\n\n    return this;\n  }\n\n  key = this._normalizeHeaderKey(key);\n  headerValue = {\n    key: key,\n    value: value\n  }; // Check if the value exists and overwrite\n\n  for (var i = 0, len = this._headers.length; i < len; i++) {\n    if (this._headers[i].key === key) {\n      if (!added) {\n        // replace the first match\n        this._headers[i] = headerValue;\n        added = true;\n      } else {\n        // remove following matches\n        this._headers.splice(i, 1);\n\n        i--;\n        len--;\n      }\n    }\n  } // match not found, append the value\n\n\n  if (!added) {\n    this._headers.push(headerValue);\n  }\n\n  return this;\n};\n/**\n * Adds a header value. If the value for selected key exists, the value is appended\n * as a new field and old one is not touched.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\n\n\nMimeNode.prototype.addHeader = function (key, value) {\n  // Allow setting multiple headers at once\n  if (!value && key && typeof key === 'object') {\n    // allow {key:'content-type', value: 'text/plain'}\n    if (key.key && key.value) {\n      this.addHeader(key.key, key.value);\n    } // allow [{key:'content-type', value: 'text/plain'}]\n    else if (Array.isArray(key)) {\n        key.forEach(function (i) {\n          this.addHeader(i.key, i.value);\n        }.bind(this));\n      } // allow {'content-type': 'text/plain'}\n      else {\n          Object.keys(key).forEach(function (i) {\n            this.addHeader(i, key[i]);\n          }.bind(this));\n        }\n\n    return this;\n  } else if (Array.isArray(value)) {\n    value.forEach(function (val) {\n      this.addHeader(key, val);\n    }.bind(this));\n    return this;\n  }\n\n  this._headers.push({\n    key: this._normalizeHeaderKey(key),\n    value: value\n  });\n\n  return this;\n};\n/**\n * Retrieves the first mathcing value of a selected key\n *\n * @param {String} key Key to search for\n * @retun {String} Value for the key\n */\n\n\nMimeNode.prototype.getHeader = function (key) {\n  key = this._normalizeHeaderKey(key);\n\n  for (var i = 0, len = this._headers.length; i < len; i++) {\n    if (this._headers[i].key === key) {\n      return this._headers[i].value;\n    }\n  }\n};\n/**\n * Sets body content for current node. If the value is a string, charset is added automatically\n * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n * the charset yourself\n *\n * @param (String|Buffer) content Body content\n * @return {Object} current node\n */\n\n\nMimeNode.prototype.setContent = function (content) {\n  var _self = this;\n\n  this.content = content;\n\n  if (typeof this.content.pipe === 'function') {\n    // pre-stream handler. might be triggered if a stream is set as content\n    // and 'error' fires before anything is done with this stream\n    this._contentErrorHandler = function (err) {\n      _self.content.removeListener('error', _self._contentErrorHandler);\n\n      _self.content = err;\n    };\n\n    this.content.once('error', this._contentErrorHandler);\n  } else if (typeof this.content === 'string') {\n    this._isPlainText = libmime.isPlainText(this.content);\n\n    if (this._isPlainText && libmime.hasLongerLines(this.content, 76)) {\n      // If there are lines longer than 76 symbols/bytes do not use 7bit\n      this._hasLongLines = true;\n    }\n  }\n\n  return this;\n};\n\nMimeNode.prototype.build = function (callback) {\n  var stream = this.createReadStream();\n  var buf = [];\n  var buflen = 0;\n  var returned = false;\n  stream.on('readable', function () {\n    var chunk;\n\n    while ((chunk = stream.read()) !== null) {\n      buf.push(chunk);\n      buflen += chunk.length;\n    }\n  });\n  stream.once('error', function (err) {\n    if (returned) {\n      return;\n    }\n\n    returned = true;\n    return callback(err);\n  });\n  stream.once('end', function (chunk) {\n    if (returned) {\n      return;\n    }\n\n    returned = true;\n\n    if (chunk && chunk.length) {\n      buf.push(chunk);\n      buflen += chunk.length;\n    }\n\n    return callback(null, Buffer.concat(buf, buflen));\n  });\n};\n\nMimeNode.prototype.getTransferEncoding = function () {\n  var transferEncoding = false;\n  var contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n  if (this.content) {\n    transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n\n    if (!transferEncoding || ['base64', 'quoted-printable'].indexOf(transferEncoding) < 0) {\n      if (/^text\\//i.test(contentType)) {\n        // If there are no special symbols, no need to modify the text\n        if (this._isPlainText && !this._hasLongLines) {\n          transferEncoding = '7bit';\n        } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n          // detect preferred encoding for string value\n          transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n        } else {\n          // we can not check content for a stream, so either use preferred encoding or fallback to QP\n          transferEncoding = this.transferEncoding === 'B' ? 'base64' : 'quoted-printable';\n        }\n      } else if (!/^(multipart|message)\\//i.test(contentType)) {\n        transferEncoding = transferEncoding || 'base64';\n      }\n    }\n  }\n\n  return transferEncoding;\n};\n/**\n * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n *\n * @returns {String} Headers\n */\n\n\nMimeNode.prototype.buildHeaders = function () {\n  var _self = this;\n\n  var transferEncoding = this.getTransferEncoding();\n  var headers = [];\n\n  if (transferEncoding) {\n    this.setHeader('Content-Transfer-Encoding', transferEncoding);\n  }\n\n  if (this.filename && !this.getHeader('Content-Disposition')) {\n    this.setHeader('Content-Disposition', 'attachment');\n  } // Ensure mandatory header fields\n\n\n  if (this.rootNode === this) {\n    if (!this.getHeader('Date')) {\n      this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n    } // ensure that Message-Id is present\n\n\n    this.messageId();\n\n    if (!this.getHeader('MIME-Version')) {\n      this.setHeader('MIME-Version', '1.0');\n    }\n  }\n\n  this._headers.forEach(function (header) {\n    var key = header.key;\n    var value = header.value;\n    var structured;\n    var param;\n    var options = {};\n    var formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n    if (value && formattedHeaders.indexOf(key) < 0 && typeof value === 'object') {\n      Object.keys(value).forEach(function (key) {\n        if (key !== 'value') {\n          options[key] = value[key];\n        }\n      });\n      value = (value.value || '').toString();\n\n      if (!value.trim()) {\n        return;\n      }\n    }\n\n    if (options.prepared) {\n      // header value is\n      headers.push(key + ': ' + value);\n      return;\n    }\n\n    switch (header.key) {\n      case 'Content-Disposition':\n        structured = libmime.parseHeaderValue(value);\n\n        if (_self.filename) {\n          structured.params.filename = _self.filename;\n        }\n\n        value = libmime.buildHeaderValue(structured);\n        break;\n\n      case 'Content-Type':\n        structured = libmime.parseHeaderValue(value);\n\n        _self._handleContentType(structured);\n\n        if (structured.value.match(/^text\\/plain\\b/) && typeof _self.content === 'string' && /[\\u0080-\\uFFFF]/.test(_self.content)) {\n          structured.params.charset = 'utf-8';\n        }\n\n        value = libmime.buildHeaderValue(structured);\n\n        if (_self.filename) {\n          // add support for non-compliant clients like QQ webmail\n          // we can't build the value with buildHeaderValue as the value is non standard and\n          // would be converted to parameter continuation encoding that we do not want\n          param = this._encodeWords(_self.filename);\n\n          if (param !== _self.filename || /[\\s\"=;]/.test(param)) {\n            // include value in quotes if needed\n            param = '\"' + param + '\"';\n          }\n\n          value += '; name=' + param;\n        }\n\n        break;\n\n      case 'Bcc':\n        if (!_self.keepBcc) {\n          // skip BCC values\n          return;\n        }\n\n        break;\n    }\n\n    value = _self._encodeHeaderValue(key, value); // skip empty lines\n\n    if (!(value || '').toString().trim()) {\n      return;\n    }\n\n    headers.push(libmime.foldLines(key + ': ' + value, 76));\n  }.bind(this));\n\n  return headers.join('\\r\\n');\n};\n/**\n * Streams the rfc2822 message from the current node. If this is a root node,\n * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n *\n * @return {String} Compiled message\n */\n\n\nMimeNode.prototype.createReadStream = function (options) {\n  options = options || {};\n  var outputStream = new PassThrough(options);\n  var transform;\n  this.stream(outputStream, options, function (err) {\n    if (err) {\n      outputStream.emit('error', err);\n      return;\n    }\n\n    outputStream.end();\n  });\n\n  for (var i = 0, len = this._transforms.length; i < len; i++) {\n    transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n    outputStream.once('error', function (err) {\n      transform.emit('error', err);\n    });\n    outputStream = outputStream.pipe(transform);\n  }\n\n  return outputStream;\n};\n/**\n * Appends a transform stream object to the transforms list. Final output\n * is passed through this stream before exposing\n *\n * @param {Object} transform Read-Write stream\n */\n\n\nMimeNode.prototype.transform = function (transform) {\n  this._transforms.push(transform);\n};\n\nMimeNode.prototype.stream = function (outputStream, options, done) {\n  var _self = this;\n\n  var transferEncoding = this.getTransferEncoding();\n  var contentStream;\n  var localStream; // protect actual callback against multiple triggering\n\n  var returned = false;\n\n  var callback = function (err) {\n    if (returned) {\n      return;\n    }\n\n    returned = true;\n    done(err);\n  }; // pushes node content\n\n\n  function sendContent() {\n    if (_self.content) {\n      if (Object.prototype.toString.call(_self.content) === '[object Error]') {\n        // content is already errored\n        return callback(_self.content);\n      }\n\n      if (typeof _self.content.pipe === 'function') {\n        _self.content.removeListener('error', _self._contentErrorHandler);\n\n        _self._contentErrorHandler = function (err) {\n          return callback(err);\n        };\n\n        _self.content.once('error', _self._contentErrorHandler);\n      }\n\n      if (['quoted-printable', 'base64'].indexOf(transferEncoding) >= 0) {\n        contentStream = new (transferEncoding === 'base64' ? libbase64 : libqp).Encoder(options);\n        contentStream.pipe(outputStream, {\n          end: false\n        });\n        contentStream.once('end', finalize);\n        contentStream.once('error', function (err) {\n          return callback(err);\n        });\n        localStream = _self._getStream(_self.content);\n        localStream.pipe(contentStream);\n      } else {\n        // anything that is not QP or Base54 passes as-is\n        localStream = _self._getStream(_self.content);\n        localStream.pipe(outputStream, {\n          end: false\n        });\n        localStream.once('end', finalize);\n      }\n\n      localStream.once('error', function (err) {\n        return callback(err);\n      });\n      return;\n    } else {\n      return setImmediate(finalize);\n    }\n  } // for multipart nodes, push child nodes\n  // for content nodes end the stream\n\n\n  function finalize() {\n    var childId = 0;\n\n    var processChildNode = function () {\n      if (childId >= _self.childNodes.length) {\n        outputStream.write('\\r\\n--' + _self.boundary + '--\\r\\n');\n        return callback();\n      }\n\n      var child = _self.childNodes[childId++];\n      outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + _self.boundary + '\\r\\n');\n      child.stream(outputStream, options, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        setImmediate(processChildNode);\n      });\n    };\n\n    if (_self.multipart) {\n      setImmediate(processChildNode);\n    } else {\n      return callback();\n    }\n  }\n\n  if (this._raw) {\n    setImmediate(function () {\n      if (Object.prototype.toString.call(_self._raw) === '[object Error]') {\n        // content is already errored\n        return callback(_self._raw);\n      } // remove default error handler (if set)\n\n\n      if (typeof _self._raw.pipe === 'function') {\n        _self._raw.removeListener('error', _self._contentErrorHandler);\n      }\n\n      var raw = _self._getStream(_self._raw);\n\n      raw.pipe(outputStream, {\n        end: false\n      });\n      raw.on('error', function (err) {\n        outputStream.emit('error', err);\n      });\n      raw.on('end', finalize);\n    });\n  } else {\n    outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n    setImmediate(sendContent);\n  }\n};\n/**\n * Sets envelope to be used instead of the generated one\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\n\n\nMimeNode.prototype.setEnvelope = function (envelope) {\n  var list;\n  this._envelope = {\n    from: false,\n    to: []\n  };\n\n  if (envelope.from) {\n    list = [];\n\n    this._convertAddresses(this._parseAddresses(envelope.from), list);\n\n    list = list.filter(function (address) {\n      return address && address.address;\n    });\n\n    if (list.length && list[0]) {\n      this._envelope.from = list[0].address;\n    }\n  }\n\n  ['to', 'cc', 'bcc'].forEach(function (key) {\n    if (envelope[key]) {\n      this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n    }\n  }.bind(this));\n  this._envelope.to = this._envelope.to.map(function (to) {\n    return to.address;\n  }).filter(function (address) {\n    return address;\n  });\n  return this;\n};\n/**\n * Generates and returns an object with parsed address fields\n *\n * @return {Object} Address object\n */\n\n\nMimeNode.prototype.getAddresses = function () {\n  var addresses = {};\n\n  this._headers.forEach(function (header) {\n    var key = header.key.toLowerCase();\n\n    if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].indexOf(key) >= 0) {\n      if (!Array.isArray(addresses[key])) {\n        addresses[key] = [];\n      }\n\n      this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n    }\n  }.bind(this));\n\n  return addresses;\n};\n/**\n * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\n\n\nMimeNode.prototype.getEnvelope = function () {\n  if (this._envelope) {\n    return this._envelope;\n  }\n\n  var envelope = {\n    from: false,\n    to: []\n  };\n\n  this._headers.forEach(function (header) {\n    var list = [];\n\n    if (header.key === 'From' || !envelope.from && ['Reply-To', 'Sender'].indexOf(header.key) >= 0) {\n      this._convertAddresses(this._parseAddresses(header.value), list);\n\n      if (list.length && list[0]) {\n        envelope.from = list[0].address;\n      }\n    } else if (['To', 'Cc', 'Bcc'].indexOf(header.key) >= 0) {\n      this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n    }\n  }.bind(this));\n\n  envelope.to = envelope.to.map(function (to) {\n    return to.address;\n  });\n  return envelope;\n};\n/**\n * Returns Message-Id value. If it does not exist, then creates one\n *\n * @return {String} Message-Id value\n */\n\n\nMimeNode.prototype.messageId = function () {\n  var messageId = this.getHeader('Message-ID'); // You really should define your own Message-Id field!\n\n  if (!messageId) {\n    messageId = this._generateMessageId();\n    this.setHeader('Message-ID', messageId);\n  }\n\n  return messageId;\n};\n/**\n * Sets pregenerated content that will be used as the output of this node\n *\n * @param {String|Buffer|Stream} Raw MIME contents\n */\n\n\nMimeNode.prototype.setRaw = function (raw) {\n  var _self = this;\n\n  this._raw = raw;\n\n  if (this._raw && typeof this._raw.pipe === 'function') {\n    // pre-stream handler. might be triggered if a stream is set as content\n    // and 'error' fires before anything is done with this stream\n    this._contentErrorHandler = function (err) {\n      _self._raw.removeListener('error', _self._contentErrorHandler);\n\n      _self._raw = err;\n    };\n\n    _self._raw.once('error', this._contentErrorHandler);\n  }\n\n  return this;\n}; /////// PRIVATE METHODS\n\n/**\n * Detects and returns handle to a stream related with the content.\n *\n * @param {Mixed} content Node content\n * @returns {Object} Stream object\n */\n\n\nMimeNode.prototype._getStream = function (content) {\n  var contentStream;\n\n  if (typeof content.pipe === 'function') {\n    // assume as stream\n    return content;\n  } else if (content && typeof content.path === 'string' && !content.href) {\n    if (this.disableFileAccess) {\n      contentStream = new PassThrough();\n      setImmediate(function () {\n        contentStream.emit('error', new Error('File access rejected for ' + content.path));\n      });\n      return contentStream;\n    } // read file\n\n\n    return fs.createReadStream(content.path);\n  } else if (content && typeof content.href === 'string') {\n    if (this.disableUrlAccess) {\n      contentStream = new PassThrough();\n      setImmediate(function () {\n        contentStream.emit('error', new Error('Url access rejected for ' + content.href));\n      });\n      return contentStream;\n    } // fetch URL\n\n\n    return fetch(content.href);\n  } else {\n    // pass string or buffer content as a stream\n    contentStream = new PassThrough();\n    setImmediate(function () {\n      contentStream.end(content || '');\n    });\n    return contentStream;\n  }\n};\n/**\n * Parses addresses. Takes in a single address or an array or an\n * array of address arrays (eg. To: [[first group], [second group],...])\n *\n * @param {Mixed} addresses Addresses to be parsed\n * @return {Array} An array of address objects\n */\n\n\nMimeNode.prototype._parseAddresses = function (addresses) {\n  return [].concat.apply([], [].concat(addresses).map(function (address) {\n    if (address && address.address) {\n      address = this._convertAddresses(address);\n    }\n\n    return addressparser(address);\n  }.bind(this)));\n};\n/**\n * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n *\n * @param {String} key Key to be normalized\n * @return {String} key in Camel-Case form\n */\n\n\nMimeNode.prototype._normalizeHeaderKey = function (key) {\n  return (key || '').toString(). // no newlines in keys\n  replace(/\\r?\\n|\\r/g, ' ').trim().toLowerCase(). // use uppercase words, except MIME\n  replace(/^X\\-SMTPAPI$|^(MIME|DKIM)\\b|^[a-z]|\\-(SPF|FBL|ID|MD5)$|\\-[a-z]/ig, function (c) {\n    return c.toUpperCase();\n  }). // special case\n  replace(/^Content\\-Features$/i, 'Content-features');\n};\n/**\n * Checks if the content type is multipart and defines boundary if needed.\n * Doesn't return anything, modifies object argument instead.\n *\n * @param {Object} structured Parsed header value for 'Content-Type' key\n */\n\n\nMimeNode.prototype._handleContentType = function (structured) {\n  this.contentType = structured.value.trim().toLowerCase();\n  this.multipart = this.contentType.split('/').reduce(function (prev, value) {\n    return prev === 'multipart' ? value : false;\n  });\n\n  if (this.multipart) {\n    this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n  } else {\n    this.boundary = false;\n  }\n};\n/**\n * Generates a multipart boundary value\n *\n * @return {String} boundary value\n */\n\n\nMimeNode.prototype._generateBoundary = function () {\n  return this.rootNode.boundaryPrefix + '-?=_' + this._nodeId + '-' + this.rootNode.baseBoundary;\n};\n/**\n * Encodes a header value for use in the generated rfc2822 email.\n *\n * @param {String} key Header key\n * @param {String} value Header value\n */\n\n\nMimeNode.prototype._encodeHeaderValue = function (key, value) {\n  key = this._normalizeHeaderKey(key);\n\n  switch (key) {\n    // Structured headers\n    case 'From':\n    case 'Sender':\n    case 'To':\n    case 'Cc':\n    case 'Bcc':\n    case 'Reply-To':\n      return this._convertAddresses(this._parseAddresses(value));\n    // values enclosed in <>\n\n    case 'Message-ID':\n    case 'In-Reply-To':\n    case 'Content-Id':\n      value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n      if (value.charAt(0) !== '<') {\n        value = '<' + value;\n      }\n\n      if (value.charAt(value.length - 1) !== '>') {\n        value = value + '>';\n      }\n\n      return value;\n    // space separated list of values enclosed in <>\n\n    case 'References':\n      value = [].concat.apply([], [].concat(value || '').map(function (elm) {\n        elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n        return elm.replace(/<[^>]*>/g, function (str) {\n          return str.replace(/\\s/g, '');\n        }).split(/\\s+/);\n      })).map(function (elm) {\n        if (elm.charAt(0) !== '<') {\n          elm = '<' + elm;\n        }\n\n        if (elm.charAt(elm.length - 1) !== '>') {\n          elm = elm + '>';\n        }\n\n        return elm;\n      });\n      return value.join(' ').trim();\n\n    case 'Date':\n      if (Object.prototype.toString.call(value) === '[object Date]') {\n        return value.toUTCString().replace(/GMT/, '+0000');\n      }\n\n      value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n      return this._encodeWords(value);\n\n    default:\n      value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' '); // encodeWords only encodes if needed, otherwise the original string is returned\n\n      return this._encodeWords(value);\n  }\n};\n/**\n * Rebuilds address object using punycode and other adjustments\n *\n * @param {Array} addresses An array of address objects\n * @param {Array} [uniqueList] An array to be populated with addresses\n * @return {String} address string\n */\n\n\nMimeNode.prototype._convertAddresses = function (addresses, uniqueList) {\n  var values = [];\n  uniqueList = uniqueList || [];\n  [].concat(addresses || []).forEach(function (address) {\n    if (address.address) {\n      address.address = address.address.replace(/@.+$/, function (domain) {\n        // usernames are not touched and are kept as is even if these include unicode\n        // domains are punycoded by default\n        // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n        return '@' + punycode.toASCII(domain.substr(1));\n      });\n\n      if (!address.name) {\n        values.push(address.address);\n      } else if (address.name) {\n        values.push(this._encodeAddressName(address.name) + ' <' + address.address + '>');\n      }\n\n      if (address.address) {\n        if (!uniqueList.filter(function (a) {\n          return a.address === address.address;\n        }).length) {\n          uniqueList.push(address);\n        }\n      }\n    } else if (address.group) {\n      values.push(this._encodeAddressName(address.name) + ':' + (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim() + ';');\n    }\n  }.bind(this));\n  return values.join(', ');\n};\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\n\n\nMimeNode.prototype._encodeAddressName = function (name) {\n  if (!/^[\\w ']*$/.test(name)) {\n    if (/^[\\x20-\\x7e]*$/.test(name)) {\n      return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n    } else {\n      return libmime.encodeWord(name, this._getTextEncoding(name), 52);\n    }\n  }\n\n  return name;\n};\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\n\n\nMimeNode.prototype._encodeWords = function (value) {\n  return libmime.encodeWords(value, this._getTextEncoding(value), 52);\n};\n/**\n * Detects best mime encoding for a text value\n *\n * @param {String} value Value to check for\n * @return {String} either 'Q' or 'B'\n */\n\n\nMimeNode.prototype._getTextEncoding = function (value) {\n  value = (value || '').toString();\n  var encoding = this.textEncoding;\n  var latinLen;\n  var nonLatinLen;\n\n  if (!encoding) {\n    // count latin alphabet symbols and 8-bit range symbols + control symbols\n    // if there are more latin characters, then use quoted-printable\n    // encoding, otherwise use base64\n    nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length;\n    latinLen = (value.match(/[a-z]/gi) || []).length; // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n\n    encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n  }\n\n  return encoding;\n};\n/**\n * Generates a message id\n *\n * @return {String} Random Message-ID value\n */\n\n\nMimeNode.prototype._generateMessageId = function () {\n  return '<' + [2, 2, 2, 6].reduce( // crux to generate UUID-like random strings\n  function (prev, len) {\n    return prev + '-' + crypto.randomBytes(len).toString('hex');\n  }, crypto.randomBytes(4).toString('hex')) + '@' + // try to use the domain of the FROM address or fallback to server hostname\n  (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() + '>';\n};","map":null,"metadata":{},"sourceType":"script"}