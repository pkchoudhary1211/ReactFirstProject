{"ast":null,"code":"const _require = require('net'),\n      createConnection = _require.createConnection;\n\nconst _require2 = require('dns'),\n      resolveMx = _require2.resolveMx;\n\nconst _require3 = require('dkim-signer'),\n      DKIMSign = _require3.DKIMSign;\n\nconst CRLF = '\\r\\n';\n\nfunction dummy() {}\n\nmodule.exports = function (options) {\n  options = options || {};\n  const logger = options.logger || options.silent && {\n    debug: dummy,\n    info: dummy,\n    warn: dummy,\n    error: dummy\n  } || {\n    debug: console.log,\n    info: console.info,\n    warn: console.warn,\n    error: console.error\n  };\n  const dkimPrivateKey = (options.dkim || {}).privateKey;\n  const dkimKeySelector = (options.dkim || {}).keySelector || 'dkim';\n  const devPort = options.devPort || -1;\n  const devHost = options.devHost || 'localhost';\n  const smtpPort = options.smtpPort || 25;\n  const smtpHost = options.smtpHost || -1;\n  /*\n   *   邮件服务返回代码含义 Mail service return code Meaning\n   *   500   格式错误，命令不可识别（此错误也包括命令行过长）format error, command unrecognized (This error also includes command line too long)\n   *   501   参数格式错误 parameter format error\n   *   502   命令不可实现 command can not be achieved\n   *   503   错误的命令序列 Bad sequence of commands\n   *   504   命令参数不可实现 command parameter can not be achieved\n   *   211   系统状态或系统帮助响应 System status, or system help response\n   *   214   帮助信息 help\n   *   220   服务就绪 Services Ready\n   *   221   服务关闭传输信道 Service closing transmission channel\n   *   421   服务未就绪，关闭传输信道（当必须关闭时，此应答可以作为对任何命令的响应）service is not ready to close the transmission channel (when it is necessary to close, this response may be in response to any command)\n   *   250   要求的邮件操作完成 requested mail action completed\n   *   251   用户非本地，将转发向 non-local users will be forwarded to\n   *   450   要求的邮件操作未完成，邮箱不可用（例如，邮箱忙）Mail the required operation 450 unfinished, mailbox unavailable (for example, mailbox busy)\n   *   550   要求的邮件操作未完成，邮箱不可用（例如，邮箱未找到，或不可访问）Mail action not completed the required 550 mailbox unavailable (eg, mailbox not found, no access)\n   *   451   放弃要求的操作；处理过程中出错 waiver operation; processing error\n   *   551   用户非本地，请尝试 non-local user, please try\n   *   452   系统存储不足，要求的操作未执行 Less than 452 storage system, requiring action not taken\n   *   552   过量的存储分配，要求的操作未执行 excess storage allocation requires action not taken\n   *   553   邮箱名不可用，要求的操作未执行（例如邮箱格式错误） mailbox name is not available, that the requested operation is not performed (for example, mailbox format error)\n   *   354   开始邮件输入，以.结束 Start Mail input to. End\n   *   554   操作失败  The operation failed\n   *   535   用户验证失败 User authentication failed\n   *   235   用户验证成功 user authentication is successful\n   *   334   等待用户输入验证信息 waits for the user to enter authentication information\n   */\n\n  function getHost(email) {\n    const m = /[^@]+@([\\w\\d\\-\\.]+)/.exec(email);\n    return m && m[1];\n  }\n\n  function groupRecipients(recipients) {\n    let groups = {};\n    let host;\n    const recipients_length = recipients.length;\n\n    for (let i = 0; i < recipients_length; i++) {\n      host = getHost(recipients[i]);\n      (groups[host] || (groups[host] = [])).push(recipients[i]);\n    }\n\n    return groups;\n  }\n  /**\n   * connect to domain by Mx record\n   */\n\n\n  function connectMx(domain, callback) {\n    if (devPort === -1) {\n      // not in development mode -> search the MX\n      resolveMx(domain, function (err, data) {\n        if (err) {\n          return callback(err);\n        }\n\n        data.sort(function (a, b) {\n          return a.priority > b.priority;\n        });\n        logger.debug('mx resolved: ', data);\n\n        if (!data || data.length === 0) {\n          return callback(new Error('can not resolve Mx of <' + domain + '>'));\n        }\n\n        if (smtpHost !== -1) data.push({\n          exchange: smtpHost\n        });\n\n        function tryConnect(i) {\n          if (i >= data.length) return callback(new Error('can not connect to any SMTP server'));\n          const sock = createConnection(smtpPort, data[i].exchange);\n          sock.on('error', function (err) {\n            logger.error('Error on connectMx for: ', data[i], err);\n            tryConnect(++i);\n          });\n          sock.on('connect', function () {\n            logger.debug('MX connection created: ', data[i].exchange);\n            sock.removeAllListeners('error');\n            callback(null, sock);\n          });\n        }\n\n        tryConnect(0);\n      });\n    } else {\n      // development mode -> connect to the specified devPort on devHost\n      const sock = createConnection(devPort, devHost);\n      sock.on('error', function (err) {\n        callback(new Error('Error on connectMx (development) for \"' + devHost + ':' + devPort + '\": ' + err));\n      });\n      sock.on('connect', function () {\n        logger.debug('MX (development) connection created: ' + devHost + ':' + devPort);\n        sock.removeAllListeners('error');\n        callback(null, sock);\n      });\n    }\n  }\n\n  function sendToSMTP(domain, srcHost, from, recipients, body, cb) {\n    const callback = typeof cb === 'function' ? cb : function () {};\n    connectMx(domain, function (err, sock) {\n      if (err) {\n        logger.error('error on connectMx', err.stack);\n        return callback(err);\n      }\n\n      function w(s) {\n        logger.debug('send ' + domain + '>' + s);\n        sock.write(s + CRLF);\n      }\n\n      sock.setEncoding('utf8');\n      sock.on('data', function (chunk) {\n        data += chunk;\n        parts = data.split(CRLF);\n        const parts_length = parts.length - 1;\n\n        for (let i = 0, len = parts_length; i < len; i++) {\n          onLine(parts[i]);\n        }\n\n        data = parts[parts.length - 1];\n      });\n      sock.on('error', function (err) {\n        logger.error('fail to connect ' + domain);\n        callback(err);\n      });\n      let data = '';\n      let step = 0;\n      let loginStep = 0;\n      const queue = [];\n      const login = [];\n      let parts;\n      let cmd;\n      /*\n       if(mail.user && mail.pass){\n         queue.push('AUTH LOGIN');\n         login.push(new Buffer(mail.user).toString(\"base64\"));\n         login.push(new Buffer(mail.pass).toString(\"base64\"));\n       }\n       */\n\n      queue.push('MAIL FROM:<' + from + '>');\n      const recipients_length = recipients.length;\n\n      for (let i = 0; i < recipients_length; i++) {\n        queue.push('RCPT TO:<' + recipients[i] + '>');\n      }\n\n      queue.push('DATA');\n      queue.push('QUIT');\n      queue.push('');\n\n      function response(code, msg) {\n        switch (code) {\n          case 220:\n            //*   220   on server ready\n            //*   220   服务就绪\n            if (/\\besmtp\\b/i.test(msg)) {\n              // TODO:  determin AUTH type; auth login, auth crm-md5, auth plain\n              cmd = 'EHLO';\n            } else {\n              cmd = 'HELO';\n            }\n\n            w(cmd + ' ' + srcHost);\n            break;\n\n          case 221: // bye\n\n          case 235: // verify ok\n\n          case 250: // operation OK\n\n          case 251:\n            // foward\n            if (step === queue.length - 1) {\n              logger.info('OK:', code, msg);\n              callback(null, msg);\n            }\n\n            w(queue[step]);\n            step++;\n            break;\n\n          case 354:\n            // start input end with . (dot)\n            logger.info('sending mail', body);\n            w(body);\n            w('');\n            w('.');\n            break;\n\n          case 334:\n            // input login\n            w(login[loginStep]);\n            loginStep++;\n            break;\n\n          default:\n            if (code >= 400) {\n              logger.warn('SMTP responds error code', code);\n              callback(new Error('SMTP code:' + code + ' msg:' + msg));\n              sock.end();\n            }\n\n        }\n      }\n\n      let msg = '';\n\n      function onLine(line) {\n        logger.debug('recv ' + domain + '>' + line);\n        msg += line + CRLF;\n\n        if (line[3] === ' ') {\n          // 250-information dash is not complete.\n          // 250 OK. space is complete.\n          let lineNumber = parseInt(line);\n          response(lineNumber, msg);\n          msg = '';\n        }\n      }\n    });\n  }\n\n  function getAddress(address) {\n    return address.replace(/^.+</, '').replace(/>\\s*$/, '').trim();\n  }\n\n  function getAddresses(addresses) {\n    const results = [];\n\n    if (!Array.isArray(addresses)) {\n      addresses = addresses.split(',');\n    }\n\n    const addresses_length = addresses.length;\n\n    for (let i = 0; i < addresses_length; i++) {\n      results.push(getAddress(addresses[i]));\n    }\n\n    return results;\n  }\n  /**\n   * sendmail directly\n   *\n   * @param mail {object}\n   *             from\n   *             to\n   *             cc\n   *             bcc\n   *             replyTo\n   *             returnTo\n   *             subject\n   *             type         default 'text/plain', 'text/html'\n   *             charset      default 'utf-8'\n   *             encoding     default 'base64'\n   *             id           default timestamp+from\n   *             headers      object\n   *             content\n   *             attachments\n   *               [{\n   *                 type\n   *                 filename\n   *                 content\n   *               }].\n   *\n   * @param callback function(err, domain).\n   *\n   */\n\n\n  function sendmail(mail, callback) {\n    const mailcomposer = require('mailcomposer');\n\n    const mailMe = mailcomposer(mail);\n    let recipients = [];\n    let groups;\n    let srcHost;\n\n    if (mail.to) {\n      recipients = recipients.concat(getAddresses(mail.to));\n    }\n\n    if (mail.cc) {\n      recipients = recipients.concat(getAddresses(mail.cc));\n    }\n\n    if (mail.bcc) {\n      recipients = recipients.concat(getAddresses(mail.bcc));\n    }\n\n    groups = groupRecipients(recipients);\n    const from = getAddress(mail.from);\n    srcHost = getHost(from);\n    mailMe.build(function (err, message) {\n      if (err) {\n        logger.error('Error on creating message : ', err);\n        callback(err, null);\n        return;\n      }\n\n      if (dkimPrivateKey) {\n        const signature = DKIMSign(message, {\n          privateKey: dkimPrivateKey,\n          keySelector: dkimKeySelector,\n          domainName: srcHost\n        });\n        message = signature + '\\r\\n' + message;\n      }\n\n      for (let domain in groups) {\n        sendToSMTP(domain, srcHost, from, groups[domain], message, callback);\n      }\n    });\n  }\n\n  return sendmail;\n};","map":null,"metadata":{},"sourceType":"script"}