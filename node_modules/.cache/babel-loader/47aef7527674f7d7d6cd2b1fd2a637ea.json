{"ast":null,"code":"'use strict';\n\nvar stream = require('stream');\n\nvar util = require('util');\n\nvar Transform = stream.Transform; // expose to the world\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  wrap: wrap,\n  Encoder: Encoder,\n  Decoder: Decoder\n};\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\n\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = new Buffer(buffer, 'utf-8');\n  } // usable characters that do not need encoding\n\n\n  var ranges = [// https://tools.ietf.org/html/rfc2045#section-6.7\n  [0x09], // <TAB>\n  [0x0A], // <LF>\n  [0x0D], // <CR>\n  [0x20, 0x3C], // <SP>!\"#$%&'()*+,-./0123456789:;\n  [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n  ];\n  var result = '';\n  var ord;\n\n  for (var i = 0, len = buffer.length; i < len; i++) {\n    ord = buffer[i]; // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n\n    if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n      result += String.fromCharCode(ord);\n      continue;\n    }\n\n    result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n  }\n\n  return result;\n}\n/**\n * Decodes a Quoted-Printable encoded string to a Buffer object\n *\n * @param {String} str Quoted-Printable encoded string\n * @returns {Buffer} Decoded value\n */\n\n\nfunction decode(str) {\n  str = (str || '').toString(). // remove invalid whitespace from the end of lines\n  replace(/[\\t ]+$/gm, ''). // remove soft line breaks\n  replace(/\\=(?:\\r?\\n|$)/g, '');\n  var encodedBytesCount = (str.match(/\\=[\\da-fA-F]{2}/g) || []).length,\n      bufferLength = str.length - encodedBytesCount * 2,\n      chr,\n      hex,\n      buffer = new Buffer(bufferLength),\n      bufferPos = 0;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    chr = str.charAt(i);\n\n    if (chr === '=' && (hex = str.substr(i + 1, 2)) && /[\\da-fA-F]{2}/.test(hex)) {\n      buffer[bufferPos++] = parseInt(hex, 16);\n      i += 2;\n      continue;\n    }\n\n    buffer[bufferPos++] = chr.charCodeAt(0);\n  }\n\n  return buffer;\n}\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\n\n\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n\n  if (str.length <= lineLength) {\n    return str;\n  }\n\n  var pos = 0,\n      len = str.length,\n      match,\n      code,\n      line,\n      lineMargin = Math.floor(lineLength / 3),\n      result = ''; // insert soft linebreaks where needed\n\n  while (pos < len) {\n    line = str.substr(pos, lineLength);\n\n    if (match = line.match(/\\r\\n/)) {\n      line = line.substr(0, match.index + match[0].length);\n      result += line;\n      pos += line.length;\n      continue;\n    }\n\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1));\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t\\.,!\\?][^ \\t\\.,!\\?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1));\n    } else {\n      if (line.match(/\\=[\\da-f]{0,2}$/i)) {\n        // push incomplete encoding sequences to the next line\n        if (match = line.match(/\\=[\\da-f]{0,1}$/i)) {\n          line = line.substr(0, line.length - match[0].length);\n        } // ensure that utf-8 sequences are not split\n\n\n        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/\\=[\\da-f]{2}$/ig))) {\n          code = parseInt(match[0].substr(1, 2), 16);\n\n          if (code < 128) {\n            break;\n          }\n\n          line = line.substr(0, line.length - 3);\n\n          if (code >= 0xC0) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === lineLength && line.match(/\\=[\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3);\n      } else if (line.length === lineLength) {\n        line = line.substr(0, line.length - 1);\n      }\n\n      pos += line.length;\n      line += '=\\r\\n';\n    } else {\n      pos += line.length;\n    }\n\n    result += line;\n  }\n\n  return result;\n}\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\n\n\nfunction checkRanges(nr, ranges) {\n  for (var i = ranges.length - 1; i >= 0; i--) {\n    if (!ranges[i].length) {\n      continue;\n    }\n\n    if (ranges[i].length === 1 && nr === ranges[i][0]) {\n      return true;\n    }\n\n    if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\n\n\nfunction Encoder(options) {\n  // init Transform\n  this.options = options || {};\n\n  if (this.options.lineLength !== false) {\n    this.options.lineLength = this.options.lineLength || 76;\n  }\n\n  this._curLine = '';\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\n\nutil.inherits(Encoder, Transform);\n\nEncoder.prototype._transform = function (chunk, encoding, done) {\n  var qp,\n      _self = this;\n\n  if (encoding !== 'buffer') {\n    chunk = new Buffer(chunk, encoding);\n  }\n\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n\n  this.inputBytes += chunk.length;\n\n  if (this.options.lineLength) {\n    qp = this._curLine + encode(chunk);\n    qp = wrap(qp, this.options.lineLength);\n    qp = qp.replace(/(^|\\n)([^\\n]*)$/, function (match, lineBreak, lastLine) {\n      _self._curLine = lastLine;\n      return lineBreak;\n    });\n\n    if (qp) {\n      this.outputBytes += qp.length;\n      this.push(qp);\n    }\n  } else {\n    qp = encode(chunk);\n    this.outputBytes += qp.length;\n    this.push(qp, 'ascii');\n  }\n\n  done();\n};\n\nEncoder.prototype._flush = function (done) {\n  if (this._curLine) {\n    this.outputBytes += this._curLine.length;\n    this.push(this._curLine, 'ascii');\n  }\n\n  done();\n};\n/**\n * Creates a transform stream for decoding Quoted-Printable encoded strings\n *\n * @constructor\n * @param {Object} options Stream options\n */\n\n\nfunction Decoder(options) {\n  // init Transform\n  this.options = options || {};\n  this._curLine = '';\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\n\nutil.inherits(Decoder, Transform);\n\nDecoder.prototype._transform = function (chunk, encoding, done) {\n  var qp,\n      buf,\n      _self = this;\n\n  chunk = chunk.toString('ascii');\n\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n\n  this.inputBytes += chunk.length;\n  qp = this._curLine + chunk;\n  this._curLine = '';\n  qp = qp.replace(/=[^\\n]?$/, function (lastLine) {\n    _self._curLine = lastLine;\n    return '';\n  });\n\n  if (qp) {\n    buf = decode(qp);\n    this.outputBytes += buf.length;\n    this.push(buf);\n  }\n\n  done();\n};\n\nDecoder.prototype._flush = function (done) {\n  var qp, buf;\n\n  if (this._curLine) {\n    buf = decode(this._curLine);\n    this.outputBytes += buf.length;\n    this.push(buf);\n  }\n\n  done();\n};","map":null,"metadata":{},"sourceType":"script"}