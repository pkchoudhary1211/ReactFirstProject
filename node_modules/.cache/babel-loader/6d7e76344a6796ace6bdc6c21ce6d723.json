{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\n\nvar libmime = require('libmime');\n\nvar punycode = require('punycode');\n/**\n * @namespace DKIM Signer module\n * @name dkimsign\n */\n\n\nmodule.exports.DKIMSign = DKIMSign;\nmodule.exports.generateDKIMHeader = generateDKIMHeader;\nmodule.exports.sha256 = sha256;\n/**\n * <p>Sign an email with provided DKIM key, uses RSA-SHA256.</p>\n *\n * @memberOf dkimsign\n * @param {String} email Full e-mail source complete with headers and body to sign\n * @param {Object} options DKIM options\n * @param {String} [options.headerFieldNames='from:to:cc:subject'] Header fields to sign\n * @param {String} options.privateKey DKMI private key\n * @param {String} options.domainName Domain name to use for signing (ie: 'domain.com')\n * @param {String} options.keySelector Selector for the DKMI public key (ie. 'dkim' if you have set up a TXT record for 'dkim._domainkey.domain.com')\n *\n * @return {String} Signed DKIM-Signature header field for prepending\n */\n\nfunction DKIMSign(email, options) {\n  options = options || {};\n  email = (email || '').toString('utf-8');\n  var match = email.match(/^\\r?\\n|(?:\\r?\\n){2}/),\n      headers = match && email.substr(0, match.index) || '',\n      body = match && email.substr(match.index + match[0].length) || email; // all listed fields from RFC4871 #5.5\n  // Some prociders do not like Message-Id, Date, Bounces-To and Return-Path\n  // fields in DKIM signed data so these are not automatcially included\n\n  var defaultFieldNames = 'From:Sender:Reply-To:Subject:To:' + 'Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:' + 'Content-Description:Resent-Date:Resent-From:Resent-Sender:' + 'Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:' + 'List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:' + 'List-Owner:List-Archive';\n  var dkim = generateDKIMHeader(options.domainName, options.keySelector, options.headerFieldNames || defaultFieldNames, headers, body),\n      canonicalizedHeaderData = DKIMCanonicalizer.relaxedHeaders(headers, options.headerFieldNames || defaultFieldNames),\n      canonicalizedDKIMHeader = DKIMCanonicalizer.relaxedHeaderLine(dkim),\n      signer,\n      signature;\n  canonicalizedHeaderData.headers += canonicalizedDKIMHeader.key + ':' + canonicalizedDKIMHeader.value;\n  signer = crypto.createSign('RSA-SHA256');\n  signer.update(canonicalizedHeaderData.headers);\n  signature = signer.sign(options.privateKey, 'base64');\n  return dkim + signature.replace(/(^.{73}|.{75}(?!\\r?\\n|\\r))/g, '$&\\r\\n ').trim();\n}\n/**\n * <p>Generates a DKIM-Signature header field without the signature part ('b=' is empty)</p>\n *\n * @memberOf dkimsign\n * @private\n * @param {String} domainName Domain name to use for signing\n * @param {String} keySelector Selector for the DKMI public key\n * @param {String} headerFieldNames Header fields to sign\n * @param {String} headers E-mail headers\n * @param {String} body E-mail body\n *\n * @return {String} Mime folded DKIM-Signature string\n */\n\n\nfunction generateDKIMHeader(domainName, keySelector, headerFieldNames, headers, body) {\n  var canonicalizedBody = DKIMCanonicalizer.relaxedBody(body),\n      canonicalizedBodyHash = sha256(canonicalizedBody, 'base64'),\n      canonicalizedHeaderData = DKIMCanonicalizer.relaxedHeaders(headers, headerFieldNames),\n      dkim;\n\n  if (hasUTFChars(domainName)) {\n    domainName = punycode.toASCII(domainName);\n  }\n\n  dkim = ['v=1', 'a=rsa-sha256', 'c=relaxed/relaxed', 'd=' + domainName, 'q=dns/txt', 's=' + keySelector, 'bh=' + canonicalizedBodyHash, 'h=' + canonicalizedHeaderData.fieldNames].join('; ');\n  return libmime.foldLines('DKIM-Signature: ' + dkim, 76) + ';\\r\\n b=';\n}\n/**\n * <p>DKIM canonicalization functions</p>\n *\n * @memberOf dkimsign\n * @private\n */\n\n\nvar DKIMCanonicalizer = {\n  /**\n   * <p>Simple body canonicalization by rfc4871 #3.4.3</p>\n   *\n   * @param {String} body E-mail body part\n   * @return {String} Canonicalized body\n   */\n  simpleBody: function (body) {\n    return (body || '').toString().replace(/(?:\\r?\\n|\\r)*$/, '\\r\\n');\n  },\n\n  /**\n   * <p>Relaxed body canonicalization by rfc4871 #3.4.4</p>\n   *\n   * @param {String} body E-mail body part\n   * @return {String} Canonicalized body\n   */\n  relaxedBody: function (body) {\n    return (body || '').toString().replace(/\\r?\\n|\\r/g, '\\n').split('\\n').map(function (line) {\n      return line.replace(/\\s*$/, ''). //rtrim\n      replace(/\\s+/g, ' '); // only single spaces\n    }).join('\\n').replace(/\\n*$/, '\\n').replace(/\\n/g, '\\r\\n');\n  },\n\n  /**\n   * <p>Relaxed headers canonicalization by rfc4871 #3.4.2 with filtering</p>\n   *\n   * @param {String} body E-mail headers part\n   * @return {String} Canonicalized headers\n   */\n  relaxedHeaders: function (headers, fieldNames) {\n    var includedFields = (fieldNames || '').toLowerCase().split(':').map(function (field) {\n      return field.trim();\n    }),\n        headerFields = {},\n        headerLines = headers.split(/\\r?\\n|\\r/),\n        line,\n        i; // join lines\n\n    for (i = headerLines.length - 1; i >= 0; i--) {\n      if (i && headerLines[i].match(/^\\s/)) {\n        headerLines[i - 1] += headerLines.splice(i, 1);\n      } else {\n        line = DKIMCanonicalizer.relaxedHeaderLine(headerLines[i]); // on multiple values, include only the first one (the one in the bottom of the list)\n\n        if (includedFields.indexOf(line.key) >= 0 && !(line.key in headerFields)) {\n          headerFields[line.key] = line.value;\n        }\n      }\n    }\n\n    headers = [];\n\n    for (i = includedFields.length - 1; i >= 0; i--) {\n      if (!headerFields[includedFields[i]]) {\n        includedFields.splice(i, 1);\n      } else {\n        headers.unshift(includedFields[i] + ':' + headerFields[includedFields[i]]);\n      }\n    }\n\n    return {\n      headers: headers.join('\\r\\n') + '\\r\\n',\n      fieldNames: includedFields.join(':')\n    };\n  },\n\n  /**\n   * <p>Relaxed header canonicalization for single header line</p>\n   *\n   * @param {String} line Single header line\n   * @return {String} Canonicalized header line\n   */\n  relaxedHeaderLine: function (line) {\n    var value = line.split(':'),\n        key = (value.shift() || '').toLowerCase().trim();\n    value = value.join(':').replace(/\\s+/g, ' ').trim();\n    return {\n      key: key,\n      value: value\n    };\n  }\n};\nmodule.exports.DKIMCanonicalizer = DKIMCanonicalizer;\n/**\n * <p>Generates a SHA-256 hash</p>\n *\n * @param {String} str String to be hashed\n * @param {String} [encoding='hex'] Output encoding\n * @return {String} SHA-256 hash in the selected output encoding\n */\n\nfunction sha256(str, encoding) {\n  var shasum = crypto.createHash('sha256');\n  shasum.update(str);\n  return shasum.digest(encoding || 'hex');\n}\n/**\n * <p>Detects if a string includes unicode symbols</p>\n *\n * @param {String} str String to be checked\n * @return {String} true, if string contains non-ascii symbols\n */\n\n\nfunction hasUTFChars(str) {\n  var rforeign = /[^\\u0000-\\u007f]/;\n  return !!rforeign.test(str);\n}","map":null,"metadata":{},"sourceType":"script"}