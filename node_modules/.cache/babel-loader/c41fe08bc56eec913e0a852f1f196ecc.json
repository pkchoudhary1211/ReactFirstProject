{"ast":null,"code":"'use strict';\n\nvar BuildMail = require('buildmail');\n\nvar libmime = require('libmime');\n\nmodule.exports = function (mail) {\n  return new MailComposer(mail).compile();\n};\n\nmodule.exports.MailComposer = MailComposer;\n/**\n * Creates the object for composing a BuildMail instance out from the mail options\n *\n * @constructor\n * @param {Object} mail Mail options\n */\n\nfunction MailComposer(mail) {\n  if (!(this instanceof MailComposer)) {\n    return new MailComposer(mail);\n  }\n\n  this.mail = mail || {};\n  this.message = false;\n}\n/**\n * Builds BuildMail instance\n */\n\n\nMailComposer.prototype.compile = function () {\n  this._alternatives = this.getAlternatives();\n  this._htmlNode = this._alternatives.filter(function (alternative) {\n    return /^text\\/html\\b/i.test(alternative.contentType);\n  }).pop();\n  this._attachments = this.getAttachments(!!this._htmlNode);\n  this._useRelated = !!(this._htmlNode && this._attachments.related.length);\n  this._useAlternative = this._alternatives.length > 1;\n  this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1; // Compose MIME tree\n\n  if (this.mail.raw) {\n    this.message = new BuildMail().setRaw(this.mail.raw);\n  } else if (this._useMixed) {\n    this.message = this._createMixed();\n  } else if (this._useAlternative) {\n    this.message = this._createAlternative();\n  } else if (this._useRelated) {\n    this.message = this._createRelated();\n  } else {\n    this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {\n      contentType: 'text/plain',\n      content: ''\n    });\n  } // Add custom headers\n\n\n  if (this.mail.headers) {\n    this.message.addHeader(this.mail.headers);\n  } // Add headers to the root node, always overrides custom headers\n\n\n  ['from', 'sender', 'to', 'cc', 'bcc', 'reply-to', 'in-reply-to', 'references', 'subject', 'message-id', 'date'].forEach(function (header) {\n    var key = header.replace(/-(\\w)/g, function (o, c) {\n      return c.toUpperCase();\n    });\n\n    if (this.mail[key]) {\n      this.message.setHeader(header, this.mail[key]);\n    }\n  }.bind(this)); // Sets custom envelope\n\n  if (this.mail.envelope) {\n    this.message.setEnvelope(this.mail.envelope);\n  } // ensure Message-Id value\n\n\n  this.message.messageId();\n  return this.message;\n};\n/**\n * List all attachments. Resulting attachment objects can be used as input for BuildMail nodes\n *\n * @param {Boolean} findRelated If true separate related attachments from attached ones\n * @returns {Object} An object of arrays (`related` and `attached`)\n */\n\n\nMailComposer.prototype.getAttachments = function (findRelated) {\n  var attachments = [].concat(this.mail.attachments || []).map(function (attachment, i) {\n    var data;\n    var isMessageNode = /^message\\//i.test(attachment.contentType);\n\n    if (/^data:/i.test(attachment.path || attachment.href)) {\n      attachment = this._processDataUrl(attachment);\n    }\n\n    data = {\n      contentType: attachment.contentType || libmime.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin'),\n      contentDisposition: attachment.contentDisposition || (isMessageNode ? 'inline' : 'attachment'),\n      contentTransferEncoding: attachment.contentTransferEncoding\n    };\n\n    if (attachment.filename) {\n      data.filename = attachment.filename;\n    } else if (!isMessageNode && attachment.filename !== false) {\n      data.filename = (attachment.path || attachment.href || '').split('/').pop() || 'attachment-' + (i + 1);\n\n      if (data.filename.indexOf('.') < 0) {\n        data.filename += '.' + libmime.detectExtension(data.contentType);\n      }\n    }\n\n    if (/^https?:\\/\\//i.test(attachment.path)) {\n      attachment.href = attachment.path;\n      attachment.path = undefined;\n    }\n\n    if (attachment.cid) {\n      data.cid = attachment.cid;\n    }\n\n    if (attachment.raw) {\n      data.raw = attachment.raw;\n    } else if (attachment.path) {\n      data.content = {\n        path: attachment.path\n      };\n    } else if (attachment.href) {\n      data.content = {\n        href: attachment.href\n      };\n    } else {\n      data.content = attachment.content || '';\n    }\n\n    if (attachment.encoding) {\n      data.encoding = attachment.encoding;\n    }\n\n    if (attachment.headers) {\n      data.headers = attachment.headers;\n    }\n\n    return data;\n  }.bind(this));\n\n  if (!findRelated) {\n    return {\n      attached: attachments,\n      related: []\n    };\n  } else {\n    return {\n      attached: attachments.filter(function (attachment) {\n        return !attachment.cid;\n      }),\n      related: attachments.filter(function (attachment) {\n        return !!attachment.cid;\n      })\n    };\n  }\n};\n/**\n * List alternatives. Resulting objects can be used as input for BuildMail nodes\n *\n * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well\n */\n\n\nMailComposer.prototype.getAlternatives = function () {\n  var alternatives = [],\n      text,\n      html,\n      watchHtml,\n      icalEvent;\n\n  if (this.mail.text) {\n    if (typeof this.mail.text === 'object' && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {\n      text = this.mail.text;\n    } else {\n      text = {\n        content: this.mail.text\n      };\n    }\n\n    text.contentType = 'text/plain' + (!text.encoding && libmime.isPlainText(text.content) ? '' : '; charset=utf-8');\n  }\n\n  if (this.mail.watchHtml) {\n    if (typeof this.mail.watchHtml === 'object' && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {\n      watchHtml = this.mail.watchHtml;\n    } else {\n      watchHtml = {\n        content: this.mail.watchHtml\n      };\n    }\n\n    watchHtml.contentType = 'text/watch-html' + (!watchHtml.encoding && libmime.isPlainText(watchHtml.content) ? '' : '; charset=utf-8');\n  }\n\n  if (this.mail.icalEvent) {\n    if (typeof this.mail.icalEvent === 'object' && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {\n      icalEvent = this.mail.icalEvent;\n    } else {\n      icalEvent = {\n        content: this.mail.icalEvent\n      };\n    }\n\n    icalEvent.contentType = 'text/calendar; charset=\"utf-8\"; method=' + (icalEvent.method || 'PUBLISH').toString().trim().toUpperCase();\n\n    if (!icalEvent.headers) {\n      icalEvent.headers = {};\n    }\n\n    icalEvent.headers['Content-Transfer-Encoding'] = 'base64';\n  }\n\n  if (this.mail.html) {\n    if (typeof this.mail.html === 'object' && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {\n      html = this.mail.html;\n    } else {\n      html = {\n        content: this.mail.html\n      };\n    }\n\n    html.contentType = 'text/html' + (!html.encoding && libmime.isPlainText(html.content) ? '' : '; charset=utf-8');\n  }\n\n  [].concat(text || []).concat(watchHtml || []).concat(html || []).concat(icalEvent || []).concat(this.mail.alternatives || []).forEach(function (alternative) {\n    var data;\n\n    if (/^data:/i.test(alternative.path || alternative.href)) {\n      alternative = this._processDataUrl(alternative);\n    }\n\n    data = {\n      contentType: alternative.contentType || libmime.detectMimeType(alternative.filename || alternative.path || alternative.href || 'txt'),\n      contentTransferEncoding: alternative.contentTransferEncoding\n    };\n\n    if (alternative.filename) {\n      data.filename = alternative.filename;\n    }\n\n    if (/^https?:\\/\\//i.test(alternative.path)) {\n      alternative.href = alternative.path;\n      alternative.path = undefined;\n    }\n\n    if (alternative.raw) {\n      data.raw = alternative.raw;\n    } else if (alternative.path) {\n      data.content = {\n        path: alternative.path\n      };\n    } else if (alternative.href) {\n      data.content = {\n        href: alternative.href\n      };\n    } else {\n      data.content = alternative.content || '';\n    }\n\n    if (alternative.encoding) {\n      data.encoding = alternative.encoding;\n    }\n\n    if (alternative.headers) {\n      data.headers = alternative.headers;\n    }\n\n    alternatives.push(data);\n  }.bind(this));\n  return alternatives;\n};\n/**\n * Builds multipart/mixed node. It should always contain different type of elements on the same level\n * eg. text + attachments\n *\n * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n * @returns {Object} BuildMail node element\n */\n\n\nMailComposer.prototype._createMixed = function (parentNode) {\n  var node;\n\n  if (!parentNode) {\n    node = new BuildMail('multipart/mixed', {\n      baseBoundary: this.mail.baseBoundary,\n      textEncoding: this.mail.textEncoding,\n      boundaryPrefix: this.mail.boundaryPrefix,\n      disableUrlAccess: this.mail.disableUrlAccess,\n      disableFileAccess: this.mail.disableFileAccess\n    });\n  } else {\n    node = parentNode.createChild('multipart/mixed', {\n      disableUrlAccess: this.mail.disableUrlAccess,\n      disableFileAccess: this.mail.disableFileAccess\n    });\n  }\n\n  if (this._useAlternative) {\n    this._createAlternative(node);\n  } else if (this._useRelated) {\n    this._createRelated(node);\n  }\n\n  [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach(function (element) {\n    // if the element is a html node from related subpart then ignore it\n    if (!this._useRelated || element !== this._htmlNode) {\n      this._createContentNode(node, element);\n    }\n  }.bind(this));\n  return node;\n};\n/**\n * Builds multipart/alternative node. It should always contain same type of elements on the same level\n * eg. text + html view of the same data\n *\n * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n * @returns {Object} BuildMail node element\n */\n\n\nMailComposer.prototype._createAlternative = function (parentNode) {\n  var node;\n\n  if (!parentNode) {\n    node = new BuildMail('multipart/alternative', {\n      baseBoundary: this.mail.baseBoundary,\n      textEncoding: this.mail.textEncoding,\n      boundaryPrefix: this.mail.boundaryPrefix,\n      disableUrlAccess: this.mail.disableUrlAccess,\n      disableFileAccess: this.mail.disableFileAccess\n    });\n  } else {\n    node = parentNode.createChild('multipart/alternative', {\n      disableUrlAccess: this.mail.disableUrlAccess,\n      disableFileAccess: this.mail.disableFileAccess\n    });\n  }\n\n  this._alternatives.forEach(function (alternative) {\n    if (this._useRelated && this._htmlNode === alternative) {\n      this._createRelated(node);\n    } else {\n      this._createContentNode(node, alternative);\n    }\n  }.bind(this));\n\n  return node;\n};\n/**\n * Builds multipart/related node. It should always contain html node with related attachments\n *\n * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n * @returns {Object} BuildMail node element\n */\n\n\nMailComposer.prototype._createRelated = function (parentNode) {\n  var node;\n\n  if (!parentNode) {\n    node = new BuildMail('multipart/related; type=\"text/html\"', {\n      baseBoundary: this.mail.baseBoundary,\n      textEncoding: this.mail.textEncoding,\n      boundaryPrefix: this.mail.boundaryPrefix,\n      disableUrlAccess: this.mail.disableUrlAccess,\n      disableFileAccess: this.mail.disableFileAccess\n    });\n  } else {\n    node = parentNode.createChild('multipart/related; type=\"text/html\"', {\n      disableUrlAccess: this.mail.disableUrlAccess,\n      disableFileAccess: this.mail.disableFileAccess\n    });\n  }\n\n  this._createContentNode(node, this._htmlNode);\n\n  this._attachments.related.forEach(function (alternative) {\n    this._createContentNode(node, alternative);\n  }.bind(this));\n\n  return node;\n};\n/**\n * Creates a regular node with contents\n *\n * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n * @param {Object} element Node data\n * @returns {Object} BuildMail node element\n */\n\n\nMailComposer.prototype._createContentNode = function (parentNode, element) {\n  element = element || {};\n  element.content = element.content || '';\n  var node;\n  var encoding = (element.encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n\n  if (!parentNode) {\n    node = new BuildMail(element.contentType, {\n      filename: element.filename,\n      baseBoundary: this.mail.baseBoundary,\n      textEncoding: this.mail.textEncoding,\n      boundaryPrefix: this.mail.boundaryPrefix,\n      disableUrlAccess: this.mail.disableUrlAccess,\n      disableFileAccess: this.mail.disableFileAccess\n    });\n  } else {\n    node = parentNode.createChild(element.contentType, {\n      filename: element.filename,\n      disableUrlAccess: this.mail.disableUrlAccess,\n      disableFileAccess: this.mail.disableFileAccess\n    });\n  } // add custom headers\n\n\n  if (element.headers) {\n    node.addHeader(element.headers);\n  }\n\n  if (element.cid) {\n    node.setHeader('Content-Id', '<' + element.cid.replace(/[<>]/g, '') + '>');\n  }\n\n  if (element.contentTransferEncoding) {\n    node.setHeader('Content-Transfer-Encoding', element.contentTransferEncoding);\n  } else if (this.mail.encoding && /^text\\//i.test(element.contentType)) {\n    node.setHeader('Content-Transfer-Encoding', this.mail.encoding);\n  }\n\n  if (!/^text\\//i.test(element.contentType) || element.contentDisposition) {\n    node.setHeader('Content-Disposition', element.contentDisposition || (element.cid ? 'inline' : 'attachment'));\n  }\n\n  if (typeof element.content === 'string' && ['utf8', 'usascii', 'ascii'].indexOf(encoding) < 0) {\n    element.content = new Buffer(element.content, encoding);\n  } // prefer pregenerated raw content\n\n\n  if (element.raw) {\n    node.setRaw(element.raw);\n  } else {\n    node.setContent(element.content);\n  }\n\n  return node;\n};\n/**\n * Parses data uri and converts it to a Buffer\n *\n * @param {Object} element Content element\n * @return {Object} Parsed element\n */\n\n\nMailComposer.prototype._processDataUrl = function (element) {\n  var parts = (element.path || element.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n\n  if (!parts) {\n    return element;\n  }\n\n  element.content = /\\bbase64$/i.test(parts[1]) ? new Buffer(parts[2], 'base64') : new Buffer(decodeURIComponent(parts[2]));\n\n  if ('path' in element) {\n    element.path = false;\n  }\n\n  if ('href' in element) {\n    element.href = false;\n  }\n\n  parts[1].split(';').forEach(function (item) {\n    if (/^\\w+\\/[^\\/]+$/i.test(item)) {\n      element.contentType = element.contentType || item.toLowerCase();\n    }\n  });\n  return element;\n};","map":null,"metadata":{},"sourceType":"script"}