{"ast":null,"code":"'use strict';\n\nvar stream = require('stream');\n\nvar util = require('util');\n\nvar Transform = stream.Transform; // expose to the world\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  wrap: wrap,\n  Encoder: Encoder,\n  Decoder: Decoder\n};\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\n\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = new Buffer(buffer, 'utf-8');\n  }\n\n  return buffer.toString('base64');\n}\n/**\n * Decodes a base64 encoded string to a Buffer object\n *\n * @param {String} str base64 encoded string\n * @returns {Buffer} Decoded value\n */\n\n\nfunction decode(str) {\n  str = str || '';\n  return new Buffer(str, 'base64');\n}\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\n\n\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n\n  if (str.length <= lineLength) {\n    return str;\n  }\n\n  return str.replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n').trim();\n}\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\n\n\nfunction Encoder(options) {\n  // init Transform\n  this.options = options || {};\n\n  if (this.options.lineLength !== false) {\n    this.options.lineLength = this.options.lineLength || 76;\n  }\n\n  this._curLine = '';\n  this._remainingBytes = false;\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\n\nutil.inherits(Encoder, Transform);\n\nEncoder.prototype._transform = function (chunk, encoding, done) {\n  var b64,\n      _self = this;\n\n  if (encoding !== 'buffer') {\n    chunk = new Buffer(chunk, encoding);\n  }\n\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n\n  this.inputBytes += chunk.length;\n\n  if (this._remainingBytes && this._remainingBytes.length) {\n    chunk = Buffer.concat([this._remainingBytes, chunk]);\n    this._remainingBytes = false;\n  }\n\n  if (chunk.length % 3) {\n    this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);\n    chunk = chunk.slice(0, chunk.length - chunk.length % 3);\n  } else {\n    this._remainingBytes = false;\n  }\n\n  b64 = this._curLine + encode(chunk);\n\n  if (this.options.lineLength) {\n    b64 = wrap(b64, this.options.lineLength);\n    b64 = b64.replace(/(^|\\n)([^\\n]*)$/, function (match, lineBreak, lastLine) {\n      _self._curLine = lastLine;\n      return lineBreak;\n    });\n  }\n\n  if (b64) {\n    this.outputBytes += b64.length;\n    this.push(b64);\n  }\n\n  done();\n};\n\nEncoder.prototype._flush = function (done) {\n  if (this._remainingBytes && this._remainingBytes.length) {\n    this._curLine += encode(this._remainingBytes);\n  }\n\n  if (this._curLine) {\n    this._curLine = wrap(this._curLine, this.options.lineLength);\n    this.outputBytes += this._curLine.length;\n    this.push(this._curLine, 'ascii');\n    this._curLine = '';\n  }\n\n  done();\n};\n/**\n * Creates a transform stream for decoding base64 encoded strings\n *\n * @constructor\n * @param {Object} options Stream options\n */\n\n\nfunction Decoder(options) {\n  // init Transform\n  this.options = options || {};\n  this._curLine = '';\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\n\nutil.inherits(Decoder, Transform);\n\nDecoder.prototype._transform = function (chunk, encoding, done) {\n  var b64, buf;\n  chunk = chunk.toString('ascii');\n\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n\n  this.inputBytes += chunk.length;\n  b64 = this._curLine + chunk;\n  this._curLine = '';\n  b64 = b64.replace(/[^a-zA-Z0-9+\\/=]/g, '');\n\n  if (b64.length % 4) {\n    this._curLine = b64.substr(-b64.length % 4);\n\n    if (this._curLine.length == b64.length) {\n      b64 = '';\n    } else {\n      b64 = b64.substr(0, this._curLine.length);\n    }\n  }\n\n  if (b64) {\n    buf = decode(b64);\n    this.outputBytes += buf.length;\n    this.push(buf);\n  }\n\n  done();\n};\n\nDecoder.prototype._flush = function (done) {\n  var b64, buf;\n\n  if (this._curLine) {\n    buf = decode(this._curLine);\n    this.outputBytes += buf.length;\n    this.push(buf);\n    this._curLine = '';\n  }\n\n  done();\n};","map":null,"metadata":{},"sourceType":"script"}