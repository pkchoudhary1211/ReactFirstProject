{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst packageData = require('../../package.json');\n\nconst shared = require('../shared');\n\nconst LeWindows = require('../sendmail-transport/le-windows');\n/**\n * Generates a Transport object for AWS SES\n *\n * Possible options can be the following:\n *\n *  * **sendingRate** optional Number specifying how many messages per second should be delivered to SES\n *  * **maxConnections** optional Number specifying max number of parallel connections to SES\n *\n * @constructor\n * @param {Object} optional config parameter\n */\n\n\nclass SESTransport extends EventEmitter {\n  constructor(options) {\n    super();\n    options = options || {};\n    this.options = options || {};\n    this.ses = this.options.SES;\n    this.name = 'SESTransport';\n    this.version = packageData.version;\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'ses-transport'\n    }); // parallel sending connections\n\n    this.maxConnections = Number(this.options.maxConnections) || Infinity;\n    this.connections = 0; // max messages per second\n\n    this.sendingRate = Number(this.options.sendingRate) || Infinity;\n    this.sendingRateTTL = null;\n    this.rateInterval = 1000;\n    this.rateMessages = [];\n    this.pending = [];\n    this.idling = true;\n    setImmediate(() => {\n      if (this.idling) {\n        this.emit('idle');\n      }\n    });\n  }\n  /**\n   * Schedules a sending of a message\n   *\n   * @param {Object} emailMessage MailComposer object\n   * @param {Function} callback Callback function to run when the sending is completed\n   */\n\n\n  send(mail, callback) {\n    if (this.connections >= this.maxConnections) {\n      this.idling = false;\n      return this.pending.push({\n        mail,\n        callback\n      });\n    }\n\n    if (!this._checkSendingRate()) {\n      this.idling = false;\n      return this.pending.push({\n        mail,\n        callback\n      });\n    }\n\n    this._send(mail, (...args) => {\n      setImmediate(() => callback(...args));\n\n      this._sent();\n    });\n  }\n\n  _checkRatedQueue() {\n    if (this.connections >= this.maxConnections || !this._checkSendingRate()) {\n      return;\n    }\n\n    if (!this.pending.length) {\n      if (!this.idling) {\n        this.idling = true;\n        this.emit('idle');\n      }\n\n      return;\n    }\n\n    let next = this.pending.shift();\n\n    this._send(next.mail, (...args) => {\n      setImmediate(() => next.callback(...args));\n\n      this._sent();\n    });\n  }\n\n  _checkSendingRate() {\n    clearTimeout(this.sendingRateTTL);\n    let now = Date.now();\n    let oldest = false; // delete older messages\n\n    for (let i = this.rateMessages.length - 1; i >= 0; i--) {\n      if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {\n        oldest = this.rateMessages[i].ts;\n      }\n\n      if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {\n        this.rateMessages.splice(i, 1);\n      }\n    }\n\n    if (this.rateMessages.length < this.sendingRate) {\n      return true;\n    }\n\n    let delay = Math.max(oldest + 1001, now + 20);\n    this.sendingRateTTL = setTimeout(() => this._checkRatedQueue(), now - delay);\n\n    try {\n      this.sendingRateTTL.unref();\n    } catch (E) {// Ignore. Happens on envs with non-node timer implementation\n    }\n\n    return false;\n  }\n\n  _sent() {\n    this.connections--;\n\n    this._checkRatedQueue();\n  }\n  /**\n   * Returns true if there are free slots in the queue\n   */\n\n\n  isIdle() {\n    return this.idling;\n  }\n  /**\n   * Compiles a mailcomposer message and forwards it to SES\n   *\n   * @param {Object} emailMessage MailComposer object\n   * @param {Function} callback Callback function to run when the sending is completed\n   */\n\n\n  _send(mail, callback) {\n    let statObject = {\n      ts: Date.now(),\n      pending: true\n    };\n    this.connections++;\n    this.rateMessages.push(statObject);\n    let envelope = mail.data.envelope || mail.message.getEnvelope();\n    let messageId = mail.message.messageId();\n    let recipients = [].concat(envelope.to || []);\n\n    if (recipients.length > 3) {\n      recipients.push('...and ' + recipients.splice(2).length + ' more');\n    }\n\n    this.logger.info({\n      tnx: 'send',\n      messageId\n    }, 'Sending message %s to <%s>', messageId, recipients.join(', '));\n\n    let getRawMessage = next => {\n      // do not use Message-ID and Date in DKIM signature\n      if (!mail.data._dkim) {\n        mail.data._dkim = {};\n      }\n\n      if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === 'string') {\n        mail.data._dkim.skipFields += ':date:message-id';\n      } else {\n        mail.data._dkim.skipFields = 'date:message-id';\n      }\n\n      let sourceStream = mail.message.createReadStream();\n      let stream = sourceStream.pipe(new LeWindows());\n      let chunks = [];\n      let chunklen = 0;\n      stream.on('readable', () => {\n        let chunk;\n\n        while ((chunk = stream.read()) !== null) {\n          chunks.push(chunk);\n          chunklen += chunk.length;\n        }\n      });\n      sourceStream.once('error', err => stream.emit('error', err));\n      stream.once('error', err => {\n        next(err);\n      });\n      stream.once('end', () => next(null, Buffer.concat(chunks, chunklen)));\n    };\n\n    setImmediate(() => getRawMessage((err, raw) => {\n      if (err) {\n        this.logger.error({\n          err,\n          tnx: 'send',\n          messageId\n        }, 'Failed creating message for %s. %s', messageId, err.message);\n        statObject.pending = false;\n        return callback(err);\n      }\n\n      let sesMessage = {\n        RawMessage: {\n          // required\n          Data: raw // required\n\n        },\n        Source: envelope.from,\n        Destinations: envelope.to\n      };\n      Object.keys(mail.data.ses || {}).forEach(key => {\n        sesMessage[key] = mail.data.ses[key];\n      });\n      this.ses.sendRawEmail(sesMessage, (err, data) => {\n        if (err) {\n          this.logger.error({\n            err,\n            tnx: 'send'\n          }, 'Send error for %s: %s', messageId, err.message);\n          statObject.pending = false;\n          return callback(err);\n        }\n\n        let region = this.ses.config && this.ses.config.region || 'us-east-1';\n\n        if (region === 'us-east-1') {\n          region = 'email';\n        }\n\n        statObject.pending = false;\n        callback(null, {\n          envelope: {\n            from: envelope.from,\n            to: envelope.to\n          },\n          messageId: '<' + data.MessageId + (!/@/.test(data.MessageId) ? '@' + region + '.amazonses.com' : '') + '>',\n          response: data.MessageId,\n          raw\n        });\n      });\n    }));\n  }\n  /**\n   * Verifies SES configuration\n   *\n   * @param {Function} callback Callback function\n   */\n\n\n  verify(callback) {\n    let promise;\n\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n\n    this.ses.sendRawEmail({\n      RawMessage: {\n        // required\n        Data: 'From: invalid@invalid\\r\\nTo: invalid@invalid\\r\\n Subject: Invalid\\r\\n\\r\\nInvalid'\n      },\n      Source: 'invalid@invalid',\n      Destinations: ['invalid@invalid']\n    }, err => {\n      if (err && err.code !== 'InvalidParameterValue') {\n        return callback(err);\n      }\n\n      return callback(null, true);\n    });\n    return promise;\n  }\n\n}\n\nmodule.exports = SESTransport;","map":null,"metadata":{},"sourceType":"script"}